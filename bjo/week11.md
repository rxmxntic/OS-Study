🔎 운영체제가 메모리 관리를 어떻게 하는지?

 

1. 운영체제의(OS)의 역할
운영체제의 가장 핵심적인 기능은 자원을 효율적으로 관리하는 것입니다.

HW : (OS의 아랫단 => cpu/memory/io장치)
SW : (OS의 윗단)
2. 메모리(Memory)란?
컴퓨터에서 정보를 처리하기 위해 일시적으로 정보를 보관하는 기억장치를 말합니다. 메모리는 CPU가 작업을 수행하는 데 있어 필요할 때 직접 엑세스 할 수 있도록 운영 체제, 응용 프로그램 및 기타 정보등을 저장하는 기억장치입니다.

메모리에는 주소가 매겨지고 프로세스는 주소를 통해 메모리에 접근하여 작업을 수행할 수 있습니다.

 

3. 메모리 주소(Memory address)
1) 논리적인 주소(Logical address)

프로그램마다 가지고 있는 메모리 주소

CPU가 바라보는 주소는 논리적인 주소입니다 왜냐하면 코드자체는 논리적인 주소로 남아있기 때문에 CPU의 작업 수행은 논리적인 주소를 바라보고 있을 수 밖에 없습니다.

 

2) 물리적인 주소(Physical address)

실제 물리적인 메모리의 주소

이 물리적인 메모리는 하나로 0번지부터 관리되기 때문에 메모리의 아랫부분에는 운영체제 커널이 올라가있고 상위에는 여러 프로그램들이 섞여서 올라가있게 됩니다.

 

CPU가 프로세스의 작업을 수행하기 위해서 프로세스의 논리적 주소를 참조하게 됩니다. 논리적 주소만으로는 실제 메모리의 주소를 알 수 없기 때문에 논리적 주소를 물리적 메모리로 연결시키는 작업이 필요합니다. 이 작업의 시점을 주소 바인딩이라고 하고 물리적인 주소로 바꾸는 작업을 주소 변환이라고 합니다

Symbolic Address => Logical Address => Physical address(프로그램이 실행되기 위해선 물리적인 주소로 바뀌어야 함)

 

4. 주소 바인딩(Address binding)

1) Complie time binding

컴파일 시 반드시 결정된 번지로 메모리에 올려되는 주소 바인딩 기법

=> 주소결정 후 바뀌지 않기 때문에 비효율 적인 방법 (현재는 사용하지 않는 방법)

이러한 방법으로 메모리에 올라가는 코드는 절대 코드라고 합니다(메모리에 올라가는 위치를 바꾸고 싶으면 컴파일을 다시해야함)

2) Load time binding

프로그램이 시작되고 메모리에 올라갈 때 주소가 비어있으면 그 번지로 물리적인 메모리 주소가 결정되는 주소바인딩기법

재배치 가능 코드(비어있는 위치에 어이든 들어갈 수 있음)

3) Run time biding

프로그램 실행 도중에 경우에 따라 주소가 바뀔 수 있는 주소 바인딩 기법(현재 사용하는 방법)

CPU가 주소를 참조할 때마다 바인딩을 점검해야 하기 때문에 하드웨어적 자원이 필요

 

5. MMU(Memory Management Unit, 메모리 관리 장치)
주소변환을 지원해주는 하드웨어(relocation register/ limit register)


relocation register를 통해 번지수가 결정됨 주소변환은 다음과 같이 계산됩니다.
물리적메모리에서 시작 위치는 요청한 번지수 물리적 메모리의 번지를 더해주면됨

ex) 346 + 14000

CPU가 번지수보다 큰 메모리 주소를 달라고 요청하면

물리적 메모리에서 다른 프로그램이 존재하는 메모리에 할당이 될 수 있음

limit register를 통해 먼저 프로그램의 크기를 체크하고 초과된 메모리 할당을 막음

 

1. Dynamic loading
프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 load하는 것
memory utilization 의 향상
운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능(OS를 통해 지원되는 라이브러리로 구현 가능)
2. Dynamic linking
https://live-everyday.tistory.com/69

 
[Linking] 정적 링킹과 동적 링킹의 차이

이번 시간에는 정적 링킹과 동적 링킹의 차이에 대해 이해해보자. 아래의 그림에서 왼쪽은 정적 링킹 방식이고 오른쪽은 동적 링킹 방식이다. 먼저 글을 찬찬히 읽은 뒤 다시 그림을 살펴보는

live-everyday.tistory.com
3. Overlays
메모리에 프로세스의 부분 중 실제 필요한 정보만을 올림
프로세스의 크기가 메모리보다 클 때 유용
운영체제의 지원없이 구현 해야
4. Swapping
프로세스를 일시적으로 메모리에서 backing store로 옮기거나 backing store에서 메로리로 옮기는 매커니즘
Swap out : 메모리에서 backing store로 옮기는 것(쫓아내는 것)\
Swap in : 위와 반대의 경우
backing store : 디스크 -> 많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공
Swap out / Swap in
일반적으로 중기 스케줄러(swapper)에의해서 swap out시킬 프로세스를 선정
우선순위 CPU스케듈링 알고리즘을 통해
우선순위가 낮은 프로세스를 swap out
우선순위가 높은 프로세스를 swap in
Compile time 혹은 load time binding에서는 원래 메모리 위치로 swap in 해야함
Execution time binding에서는 추후 빈 메모리 영역 아무 곳에나 올릴 수 있음
swap time은 대부분 transfer time(swap되는 양에 비례하는 시간)
 
6. 물리적 메모리 할당(Allocation of Physical Memory)
연속할당
고정 분할 방식
가변분할 방식
불연속할당(현재 시스템에서 메모리를 관리하는 방법) => 다음주차에!
페이징 기법
세그멘트 기법
페이징 세그먼트 기법
https://devsting.tistory.com/8 (연속 할당)
 
[OS] 운영체제의 자원관리 기능

목적 : 운영체제가 자원관리를 어떻게 하는지 알아보기 위해서 ​ [운영체제란?] 운영체제는 컴퓨터 내의 하드웨어와 사용자 및 다른 모든 소프트웨어를 관리시켜주는 하드웨어 바로 윗단에 설

devsting.tistory.com
가변 분할 방식에서 프로세스가 생성과 소멸과정을 거치면서 메모리 내 빈 공간이 생기는데 이를 hole이라고 합니다.

이 hole이 생기면서 프로세스를 새로 올릴 때, Hole의 크기보다 프로그램의 크기가 크게 되면, 메모리에 적재 하지 못하는 경우가 발생하게 되는데, 이를 외부 단편화라고 합니다.


 

7. 외부 단편화 해결 방법 = dynamic storage-allocation proble
가변 분할 방식에서 size n인 요청을 만족하는 가장 적절한 hole을 찾는 문제

1. first fit

size가 n이상인 가장 작은 hole을 찾아서 할당
2. best fit

size가 n이상인 가장 작은 hole을 찾아서 할당
hole들의 리스트가 크기순으로 정렬되지 않은 경우 
모든 hole의 리스트를 탐색
많은 수의 아주 작은 hole들이 생성됨
3. worst fit

가장 큰 hole에 할당
모든 리스트를 탐색해야함
상대적으로 아주 큰 hole들이 생성됨
속도와 이용률 측면

fist , best > worst 

 

4. compaction

hole을 한 공간으로 몰아 넣는 방법
사용중인 메모리 영역을 한군데 몰고 hole들을 다른 한 곳으로 몰아 큰 block을 만드는것
매우 비용이 많이 드는 방법
최소한의 메모리 이동으로 compaction하는 방법을 떠올릴 수 있음
한군데 몰아 넣는게 아니라 최소한의 hole로 적절한 block을 만드는 것(매우복잡한 문제)
compaction은 프로세스의 주소가 실행 시간에 동적으로
재배치 가능한 경우에만 수행될 수있다.(런타임 바인딩이 지원되는 경우)
 

이상 발표를 마치겠습니다.

출처: http://kocw.net/home/search/kemView.do?kemId=1046323

강의: 이화여자대학교, 반효경(운영체제)